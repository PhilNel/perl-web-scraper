.\" Automatically generated by Pod::Man 4.14 (Pod::Simple 3.42)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "Dotenv 3pm"
.TH Dotenv 3pm "2019-03-20" "perl v5.34.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Dotenv \- Support for "dotenv" in Perl
.SH "VERSION"
.IX Header "VERSION"
version 0.002
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    # basic operation
\&    use Dotenv;      # exports nothing
\&    Dotenv\->load;    # merge the content of .env in %ENV
\&
\&    # do it all in one line
\&    use Dotenv \-load;
\&
\&    # the source for environment variables can be a file, a filehandle,
\&    # a hash reference, an array reference and several other things
\&    # the sources are loaded in %ENV without modifying existing values
\&    Dotenv\->load(@sources);
\&
\&    # sources can also be loaded via import
\&    use Dotenv \-load => \*(Aqlocal.env\*(Aq;
\&
\&    # add some local stuff to %ENV (from a non\-file source)
\&    # (.env is the default only if there are no arguments)
\&    Dotenv\->load( \e%my_env );
\&
\&    # return a reference to a hash populated with the key/value pairs
\&    # read in the file, but do not set %ENV
\&    my $env = Dotenv\->parse(\*(Aqapp.env\*(Aq);
\&
\&    # dynamically add to %ENV
\&    local %ENV = %{ Dotenv\->parse( \e%ENV, \*(Aqtest.env\*(Aq ) };
\&
\&    # order of arguments matters, so this might yield different results
\&    # (here, values in \*(Aqtest.env\*(Aq take precedence over those in %ENV)
\&    local %ENV = %{ Dotenv\->parse( \*(Aqtest.env\*(Aq, \e%ENV ) };
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Dotenv\*(C'\fR adds support for .env <https://12factor.net/config> to Perl.
.PP
Storing configuration in the environment separate from code comes from
The Twelve-Factor App methodology. This is done via \fI.env\fR files, which
contains environment variable definitions akin to those one would write
for a shell script.
.PP
\&\f(CW\*(C`Dotenv\*(C'\fR has only two methods, and exports nothing.
.SH "METHODS"
.IX Header "METHODS"
.SS "parse"
.IX Subsection "parse"
.Vb 1
\&    $env = Dotenv\->parse(@sources);
.Ve
.PP
Parse the content of the provided sources.
.PP
Return a reference to a hash populated with the list of key/value pairs
read from the sources,
.PP
If no sources are provided, use the \fI.env\fR file in the current working
directory as the default source.
.SS "load"
.IX Subsection "load"
.Vb 1
\&    Dotenv\->load(@sources);
.Ve
.PP
Behaves exactly like parse, and also update \*(L"%ENV\*(R" in perlvar with the
key/value pairs obtained for the sources.
.PP
If no sources are provided, use the \fI.env\fR file in the current working
directory as the default source.
.PP
\&\f(CW\*(C`load\*(C'\fR can also be called while loading the module, with the sources
provided as a \s-1LIST\s0 (an empty list still means to use the default source):
.PP
.Vb 1
\&    use Dotenv \-load;
\&
\&    use Dotenv \-load => LIST;
.Ve
.ie n .SH "THE ""ENV"" FORMAT"
.el .SH "THE ``ENV'' FORMAT"
.IX Header "THE ENV FORMAT"
.SS "Data Format"
.IX Subsection "Data Format"
The \*(L"env\*(R" data format is a line-based format consisting of lines of
the form:
.PP
.Vb 1
\&    KEY=VALUE
.Ve
.PP
Comments start at the \f(CW\*(C`#\*(C'\fR character and go until the end of the line.
Blank lines are ignored.
.PP
The format is somewhat compatible with shell (so with a minimum of
effort, it's possible to read the environment variables use the
\&\f(CW\*(C`.\*(C'\fR or \f(CW\*(C`source\*(C'\fR shell builtins).
.PP
The significant differences are:
.IP "\(bu" 4
support for whitespace around the \f(CW\*(C`=\*(C'\fR sign, and trimming of whitespace,
.IP "\(bu" 4
\&\f(CW\*(C`\en\*(C'\fR expansion and \f(CW\*(C`\e\*(C'\fR\-escaping in double-quoted strings,
.IP "\(bu" 4
no support for \f(CW\*(C`\e\*(C'\fR line continuations,
.IP "\(bu" 4
no support for running shell commands via \f(CW\*(C`\`\`\*(C'\fR or \f(CW\*(C`$()\*(C'\fR,
.IP "\(bu" 4
no variable expansion (support for that is planned).
.SS "Data Sources"
.IX Subsection "Data Sources"
\&\f(CW\*(C`Dotenv\*(C'\fR can read environment variables from multiple sources:
.IP "\(bu" 4
a scalar (containing the name of a file to be read),
.IP "\(bu" 4
a reference to scalar (containing the data to be parsed),
.IP "\(bu" 4
an array reference (containing lines of data),
.IP "\(bu" 4
a glob or a filehandle (data will be read directly from it),
.IP "\(bu" 4
an object with a \f(CW\*(C`readline\*(C'\fR method (data will be read using that method),
.PP
Anything else will cause a fatal exception.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "\(bu" 4
The Twelve-Factor app methodology, <https://12factor.net/>.
.IP "\(bu" 4
Python implentation, <https://pypi.org/project/python\-dotenv/>.
.IP "\(bu" 4
Ruby implementation, <https://rubygems.org/gems/dotenv/>.
.IP "\(bu" 4
Node implementation, <https://www.npmjs.com/package/dotenv>.
.SH "ACKNOWLEDGEMENTS"
.IX Header "ACKNOWLEDGEMENTS"
The original version of this module was created as part of my work
for \s-1BOOKING.COM\s0 <http://www.booking.com/>, which authorized its
publication/distribution under the same terms as Perl itself.
.SH "AUTHOR"
.IX Header "AUTHOR"
Philippe Bruhat (BooK) <book@cpan.org>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2019 Philippe Bruhat (BooK), all rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
